## Introduction

The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems. This document defines HTTP caches and the associated header fields that control cache behavior or indicate cacheable response messages.

An HTTP cache is a local store of response messages and the subsystem that controls storage, retrieval, and deletion of messages in it. There are 2 types of cache the first one is shared cache is a cache that stores responses for reuse by more than one user; shared caches are usually (but not always) deployed as a part of an intermediary and second a private cache, in contrast, is dedicated to a single user; often, they are deployed as a component of a user agent.

Goal of HTTP caching is to reduce latency, network overhead and significantly improving performance by reusing prior response message to satisfy incoming requests.


## Quick Overview

Before diving into what RFC 9111 is about let's first understand why it matters !

The modern web feels fast not because servers are infinitely powerful, but because caching is carefully standardized. That standard is **RFC 9111**, published by the **Internet Engineering Task Force (IETF)** in 2022.

RFC 9111 defines how HTTP caching must work across browsers, proxies, CDNs, and servers. It replaces earlier caching specifications and provides a clear, unified rulebook for how responses are stored, reused, validated, and updated.

Now you'll wonder **what problem does it even solve**;
So without a common specification, every cache implementation would behave differently. Browsers might store data longer than intended. Proxies might cache private content. CDNs might serve stale data inconsistently.

RFC 9111 eliminates ambiguity by defining:

- When a response is cacheable
    
- How long it remains fresh
    
- When it must be revalidated
    
- How cache directives override one another
    
- How shared and private caches behave

This ensures predictable behavior across the entire web ecosystem.

From a security perspective, standardization is one of the first steps toward maintaining data integrity.

Improper caching can leak sensitive information or serve outdated data. RFC 9111 carefully defines how authenticated and personalized responses should be handled, ensuring private data is not accidentally stored in shared caches.

By clearly distinguishing between public and private content, and defining strict revalidation rules, it protects both users and systems.


## Storing Responses in Request

A cache _MUST NOT_ store a response to a request unless:

- the request method is understood by the cache.
    
- the response status code is final.
    
- if the response status code is 206 or 304, or the must-understand cache directive is present: the cache understands the response status code.
    
- the no-store cache directive is not present in the response.
    
- if the cache is shared: the private response directive is either not present or allows a shared cache to store a modified response
    
- if the cache is shared: the Authorization header field is not present in the request or a response directive is present that explicitly allows shared caching and
	
- the response contains at least one of the following:
    
    - a public response directive 
    - a private response directive, if the cache is not shared 
    - an Expires header field 
    - a max-age response directive 
    - if the cache is shared: an s-maxage response directive 
    - a cache extension that allows it to be cached 
    - a status code that is defined as heuristically cacheable 

## Header and Trailer Fields

### Storing Fieldds

Caches _MUST_ include all received response header fields, including unrecognized ones, when storing a response; this assures that new HTTP header fields can be successfully deployed. with few exceptions

- Headers listed in the **`Connection`** header, and some other hop-by-hop headers, **must be removed before forwarding** an HTTP message. Caches may do this **before storing** the message.
    
- Certain headers have semantics that also **require removal before forwarding**, per the HTTP spec.
    
- The **`no-cache`** and **`private`** directives can include arguments that **forbid storing specific header fields** (for all caches or only shared caches).
    
- **Proxy-specific headers must not be stored** unless the cache key includes the proxy’s identity. In practice, this applies to:
    - `Proxy-Authenticate`        
    - `Proxy-Authentication-Info`
	- `Proxy-Authorization`


### Updating Fields

Caches should regularly update response header fields from another response in several situations

But there are few exceptions
- Header fields excepted from storage.
- Header fields that the cache's stored response depends upon, as described below,
- Header fields that are automatically processed and removed by the recipient, as described below, and
- The Content Length header field.

An intuitive Example for this would be
Let's suppose a server sent a request like this : `Content-Encoding : gzip`
After receiving this request the browser decompresses the body of this request and stores it this version now this request is no longer gzipped 
Later let's say a request comes which says `Content-Encoding : br` 
now the real confusion arises because the cache will update the header and claim the body is now Brotlie compressed but body is actually decompressed
This is inconsistent and dangerous, therefore the exceptions exist.

### Storing Incomplete Responses
A cache may store an incomplete **GET 200** response or a **206 Partial Content** response if it marks it as incomplete and supports Range/Content-Range.
It may later complete the response using range requests.
A cache must not serve incomplete data as complete, partial responses must be sent with **206 (Partial Content)**.

### Combining Partial Content
A cache may combine multiple partial responses into one complete response **if they share the same strong validator**.
When combining them, it must update headers.

### Storing Responses to Authenticated Requests
A shared cache must not reuse responses to requests with an **Authorization** header unless the response explicitly allows caching (e.g., via `must-revalidate`, `public`, or `s-maxage`).